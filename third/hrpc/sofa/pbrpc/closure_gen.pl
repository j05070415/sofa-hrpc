#!/usr/bin/perl  -w

use strict;
use warnings;

#this perl script is used to generate Closure

my $kPreMaxArgs = 10;

sub PrintHead()
{
    print "#ifndef _SOFA_PBRPC_CLOSURE_H_\n";
    print "#define _SOFA_PBRPC_CLOSURE_H_\n\n";

    print "/////////////////////////////////////////////////////\n";
    print "// DO NOT EDIT!!!\n";
    print "// this header file is auto generated by perl script\n";
    print "// edit the generator if necessary\n";
    print "/////////////////////////////////////////////////////\n\n";

    print "/////////////////////////////////////////////////////\n";
    print "// This `Closure' only support pre-bind arguments.\n";
    print "// Use `ExtClosure' if you need post-bind arguments.\n";
    print "/////////////////////////////////////////////////////\n\n";

    print "/////////////////////////////////////////////////////\n";
    print "// Support:\n";
    print "// 1, Compatible with google::protobuf::Closure.\n";
    print "// 2, Support pre-bind for general function and class\n";
    print "//    method, up to 10 arguments.\n";
    print "// 3, Support pass argument by reference, though bind\n";
    print "//    always by value.\n";
    print "// 4, When bind class method, support use\n";
    print "//    \"sofa::pbrpc::shared_ptr\" as this pointer of class.\n";
    print "// 5, Support create temporary and permanent closure:\n";
    print "//    Temporary closure (self destoryed after call):\n";
    print "//        NewClosure();\n";
    print "//    Permanent closure (do not destoryed by self):\n";
    print "//        NewPermanentClosure();\n";
    print "/////////////////////////////////////////////////////\n\n";

    print "/////////////////////////////////////////////////////\n";
    print "// Usage:\n";
    print "// 1, General function:\n";
    print "//    \n";
    print "//    void f1(int pre_arg, double post_arg);\n";
    print "//    Closure* c1 = NewClosure(&f1, 1, 2.0);\n";
    print "//    c1->Run(2.0);\n";
    print "//    \n";
    print "// 2, Class method:\n";
    print "//    \n";
    print "//    class ClassA\n";
    print "//    {\n";
    print "//        public:\n";
    print "//            int m1(int pre_arg, double post_arg);\n";
    print "//    };\n";
    print "//    ClassA obj;\n";
    print "//    Closure* c3 = NewClosure(&obj, &ClassA::m1, 1, 2.0);\n";
    print "//    c3->Run();\n";
    print "//    \n";
    print "//    class ClassB : public sofa::pbrpc::enable_shared_from_this<ClassB>\n";
    print "//    {\n";
    print "//        public:\n";
    print "//            int m1(int pre_arg, double post_arg);\n";
    print "//     \n";
    print "//            void m2()\n";
    print "//            {\n";
    print "//                Closure* c4 = NewClosure(shared_from_this(), &ClassB::m1, 1, 2.0);\n";
    print "//                c4->Run(2.0);\n";
    print "//            }\n";
    print "//    };\n";
    print "//    sofa::pbrpc::shared_ptr<ClassB> ptr(new ClassB);\n";
    print "//    Closure* c5 = NewClosure(ptr, &ClassB::m1, 1, 2.0);\n";
    print "//    c5->Run();\n";
    print "//    \n";
    print "/////////////////////////////////////////////////////\n\n";

    print "#include <google/protobuf/stubs/common.h>\n";
    print "#include <sofa/pbrpc/closure_helper.h>\n\n";

    print "namespace sofa {\n";
    print "namespace pbrpc{\n";
}

sub PrintEnd
{
    print "} // namespace pbrpc\n";
    print "} // namespace sofa\n\n";

    print "#endif // _SOFA_PBRPC_CLOSURE_H_\n";
}

sub PrintClosureBase()
{
    print "
/// base class for all Closures
class ClosureBase : public google::protobuf::Closure
{
public:
    virtual ~ClosureBase() {}
    virtual bool IsSelfDelete() const = 0;
};
"
}

sub PrintClosure_Bind($$)
{
    my ($type, $num_pre_args) = @_;
    my $k;

    # print template argument list
    print "template <bool SelfDeleting";
    print ", typename ClassPointer, typename MethodClass" if ($type eq "Method");
    for ($k = 1; $k <= $num_pre_args; $k++)
    {
        print ", typename PreArg$k";
    }
    print ">\n";

    # print class definition
    my $ClassName = "${type}Closure_Bind${num_pre_args}";
    print "class ${ClassName} : public ClosureBase {\n";
    print "public:\n";

    # print typedef
    print "    typedef void (";
    print "MethodClass::" if ($type eq "Method");
    print "*${type}Type)(";
    for ($k = 1; $k <= $num_pre_args; $k++)
    {
        print "PreArg$k";
        print ", " if ($k < $num_pre_args);
    }
    print ");\n";

    # print ctor
    print "    $ClassName(";
    if ($type eq "Method")
    {
        print "ClassPointer object, MethodType method";
    }
    elsif ($type eq "Function")
    {
        print "FunctionType function";
    }
    for ($k = 1; $k <= $num_pre_args; $k++)
    {
        print ", PreArg$k pa$k";
    }
    print "):\n        ";
    if ($type eq "Method")
    {
        print "m_object(object), m_method(method)";
    }
    elsif ($type eq "Function")
    {
        print "m_function(function)";
    }
    for ($k = 1; $k <= $num_pre_args; $k++)
    {
        print ", m_pa${k}(pa${k})";
    }
    print " {}\n";

    # print the `Run' function
    print "    virtual void Run() {\n";
    print "        ConditionalAutoDeleter<SelfDeleting, ${ClassName}> self_deleter(this);\n";
    print "        return ";
    if ($type eq "Method")
    {
        print "(get_pointer(m_object)->*m_method)(";
    }
    elsif ($type eq "Function")
    {
        print "m_function(";
    }
    for ($k = 1; $k <= $num_pre_args; $k++)
    {
        print "m_pa$k";
        print ", " if $k != $num_pre_args;
    }
    print ");\n";
    print "    }\n";

    # IsSelfDelete
    print "    virtual bool IsSelfDelete() const { return SelfDeleting; }\n";

    # member variables
    print "private:\n";
    if ($type eq "Method")
    {
            print "    ClassPointer m_object;\n    MethodType m_method;\n";
    }
    if ($type eq "Function")
    {
            print "    FunctionType m_function;\n";
    }
    for ($k = 1; $k <= $num_pre_args; $k++)
    {
            print "    typename ParamTraits<PreArg${k}>::StorageType m_pa${k};\n";
    }
    print "};\n\n";
}

sub PrintAllClosure_Binds($)
{
    my ($type) = @_;
    print "////////////////////////////////////////////////////\n";

    if ($type eq "Method")
    {
        print "//////////// class method closures /////////////////\n";
    }
    else
    {
        print "//////////// nomal function closures ///////////////n";
    }
    print "////////////////////////////////////////////////////\n\n";

    for (my $num_pre_args = 0; $num_pre_args <= $kPreMaxArgs; $num_pre_args++)
    {
        PrintClosure_Bind($type, $num_pre_args);
    }
}

sub PrintNewClosure($$)
{
    my ($type, $self_deleting) = @_;
    print "////////////////////////////////////////////////////\n";
    print "//////// Closure create helper functions ///////////\n";
    print "////////////////////////////////////////////////////\n";
    if ($type eq "Method")
    {
        print "//////////// for class method //////////////////////\n\n";
    }
    else
    {
        print "//////////// for nomal function ////////////////////\n\n";
    }

    for (my $num_pre_args = 0; $num_pre_args <= $kPreMaxArgs; $num_pre_args++)
    {
        my $k;
        if ($type eq "Method" || $num_pre_args > 0)
        {
            print "template <";
            print "typename ClassPointer, typename MethodClass" if ($type eq "Method");
            for ($k = 1; $k <= $num_pre_args; $k++)
            {
                print ", " if ($type eq "Method" || $k > 1);
                print "typename PreArg$k";
            }
            print ">\n";
        }
        else
        {
            print "inline\n";
        }
        if ($self_deleting eq "false")
        {
            print "ClosureBase* NewPermanentClosure(";
        }
        else
        {
            print "ClosureBase* NewClosure(";
        }
        if ($type eq "Method")
        {
            print "ClassPointer object, void(MethodClass::*method)(";
        }
        else
        {
            print "void(*function)(";
        }
        for ($k = 1; $k <= $num_pre_args; $k++)
        {
            print "PreArg$k";
            print ", " if ($k < $num_pre_args);
        }
        print ")";
        for ($k = 1; $k <= $num_pre_args; $k++)
        {
            print "\n        , typename ParamTraits<PreArg$k>::ForwardType pa$k";
        }
        print ") {\n";

        if ($type eq "Method")
        {
            print "    return new MethodClosure_Bind${num_pre_args}<$self_deleting, ClassPointer, MethodClass";
        }
        else
        {
            print "    return new FunctionClosure_Bind${num_pre_args}<$self_deleting";
        }
        for ($k = 1; $k <= $num_pre_args; $k++)
        {
            print ", PreArg$k";
        }
        print ">(";
        if ($type eq "Method")
        {
            print "object, method";
        }
        else
        {
            print "function";
        }
        for ($k = 1; $k <= $num_pre_args; $k++)
        {
            print ", pa$k";
        }
        print ");\n}\n\n";
    }
}

# Start real work
PrintHead();
PrintClosureBase();
PrintAllClosure_Binds("Method");
PrintAllClosure_Binds("Function");
PrintNewClosure("Method", "true");
PrintNewClosure("Method", "false");
PrintNewClosure("Function", "true");
PrintNewClosure("Function", "false");
PrintEnd();

